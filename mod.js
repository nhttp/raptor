const f=r=>new Response("ERROR: "+r.message,{status:r.status||500}),q="application/json; charset=utf-8",x=r=>{const c=[];let e=-1;for(;(e=r.indexOf("/",e+1))!=-1&&(c.push(e),c.length!==3););const s=r.substring(c[2]),d=s.indexOf("?");return d!==-1?s.substring(0,d):s};export function raptor({onError:r=f,on404:c=f.bind(null,{status:404,message:"404 not found"}),sub:e=!1}={}){const s={};let d=[];return{subs:[],resolve(n,t){const o=n;o.params={},o.conn=t||{};const l=x(o.url);let a=[],h=s[o.method]||[],i=0;s.ANY&&(h=s.ANY.concat(h));for(const[p,u,T]of h)if(u.test(l)){T&&(o.params=u.exec(l).groups||{}),a=p;break}a=d.concat(a,[c]);const R=p=>{let u;try{u=p?r(p,o,R):a[i++](o,R)}catch(T){return p?r(T,o,R):R(T)}return u&&(u.then?u.then(void 0).catch(R):u)};return R()},make(n,...t){if(t=t.flat(),n==="WARE")return d=d.concat(t),this;if(n==="ERROR")return r=t[0],this;if(n==="404")return c=t[0],this;const o=n.indexOf("/"),l=o!==-1?n.substring(0,n.indexOf("/")):n;let a=o!==-1?n.substring(n.indexOf("/")):"/";if(l==="ROUTER"){a==="/"&&(a="");const h=[];for(let i=0;i<t.length;i++)if(typeof t[i]=="function"&&h.push(t[i]),typeof t[i]=="object")for(let R=0;R<t[i].subs.length;R++){const p=t[i].subs[R];p.fns=h.concat(p.fns),this.make(p.method+a+p.path,...p.fns)}return this}return e?this.subs.push({method:l,path:a,fns:t}):(s[l]=s[l]||[]).push([t,new RegExp(`^${a.replace(/\/$/,"").replace(/:(\w+)(\?)?(\.)?/g,"$2(?<$1>[^/]+)$2$3").replace(/(\/?)\*/g,"($1.*)?").replace(/\.(?=[\w(])/,"\\.")}/*$`),a.indexOf("/:")!==-1]),this},getRoute:()=>s,getWares:()=>d}}raptor.createRouter=()=>raptor({sub:!0});export class JsonResponse extends Response{constructor(c,e={}){e.headers?e.headers instanceof Headers?e.headers.set("content-type",q):e.headers["content-type"]=q:e.headers={"content-type":q},super(JSON.stringify(c),e)}}export class HttpError extends Error{constructor(c,e,s){super(e);this.message=e||"Http Error",this.status=c||500,this.name=s||"HttpError"}}
